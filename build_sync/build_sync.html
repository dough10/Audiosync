<!DOCTYPE html>
<html>
  <head lang="en">
  <meta charset="UTF-8">
  <style>
    :root {
      --header-height: 65px;
      --switch-rgb: 35, 58, 125;
      --main-color: rgb(var(--switch-rgb));
      --text-color: #ffffff;
      --background-color: #d6d6d6;
      --hover-color: #7994e344;
      --font-family: 'Roboto', 'Noto', sans-serif;
    }
    html {
      scroll-behavior: smooth;
    }
    body {
      position: absolute;
      top: 0;
      bottom:0;
      left:0;
      right:0;
      background: var(--background-color);
      font-family: var(--font-family);
      font-size: 13px;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      user-select: none;
      overflow-x: hidden;
      overflow-y: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      padding:0;
      margin:0;
      color: var(--text-color);
    }
    svg {
      width:24px;
      height:24px;
    }
    .toast {
      background: #323232;
      padding: 16px;
      display: inline-block;
      font-size: 14px;
      text-align: left;
      position: absolute;
      border-radius: 3px;
      bottom: 8px;
      left: 8px;
      color: #fff;
      z-index: 10;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
      min-width: 200px;
      cursor: pointer;
    }
    .toast > * {
      pointer-events: none;
    }
    .toast .yellow-text {
      color: yellow;
    }
    .small-button {
      padding: 8px;
      cursor: pointer;
      overflow: hidden;
      position: relative;
      border-radius: 50%;
    }
    .small-button[disabled] {
      color:grey;
      cursor: default;
    }
    .small-button > * {
      pointer-events: none;
    }
    .menu-button {
      padding: 12px;
      cursor: pointer;
      display: flex;
      color: #333333;
      justify-content: space-between;
      align-items: center;
      font-size: 16px;
      border-bottom: 1px solid #3333333d;
      position: relative;
      overflow: hidden;
    }
    .menu-button > * {
      pointer-events: none;
    }
    .menu-button div {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      text-transform: uppercase;
    }
    .menu-button:hover {
      background-color: var(--hover-color);
    }
    .card {
      color: #333333;
      max-width: 675px;
      min-width: 280px;
      padding: 0px;
      background: #fff;
      position: relative;
      margin: auto;
      border-radius: 3px;
      margin-bottom: 8px;
      box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14),0 1px 5px 0 rgba(0,0,0,0.12),0 3px 1px -2px rgba(0,0,0,0.2);
      text-align: center;
      margin-bottom: 100px;
    }
    @keyframes ripple-animation {
      to {
        transform: scale(4);
        opacity: 0;
      }
    }
    .ripple {
      position: relative;
      overflow: hidden;
      transform: translate3d(0, 0, 0);
    }
    .ripple-effect {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.4);
      animation: ripple-animation 0.7s linear;
    }
    .tab {
      display: flex;
      width:50%;
      padding: 8px;
      text-align: center;
      justify-content: center;
      color: #333333;
      cursor: pointer;
      text-transform: uppercase;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
      background-color: var(--background-color);
      overflow: hidden;
      position: relative;
      transition: background-color 0.45s ease;
      box-shadow: inset 0 -10px 10px -10px rgba(0, 0, 0, 0.2);
    }
    audiosync-tabs[disabled] .tab {
      cursor: auto;
    }
    .tab.selected {
      background-color: #ffffff;
      cursor: auto;
      box-shadow: none;
    }
    .alert {
      background: #323232;
      padding: 16px;
      display: flex;
      flex-direction: row;
      font-size: 14px;
      text-align: left;
      position: absolute;
      border-radius: 3px;
      top: 8px;
      color: #fff;
      z-index: 11;
      box-shadow: 0 8px 10px 1px rgba(0,0,0,.14), 0 3px 14px 2px rgba(0,0,0,.12), 0 5px 5px -3px rgba(0,0,0,.4);
      min-width: 200px;
      cursor: pointer;
      margin: 0 2em;
      overflow: hidden;
    }
    .alert > * {
      pointer-events: none;
    }
    .alert.hidden {
      opacity:0;
      transform: translateY(-120%);
    }
    .alert .yellow-text {
      margin-left: 30px;
      color: yellow;
      min-width: 100px;
      justify-content: center;
      align-items: center;
      display: flex;
    }
    .loading {
      display: none;
      position: absolute;
      top:0;
      bottom:0;
      left:0;
      right:0;
      opacity:0;
      background-color: rgba(255,255,255,0.6);
      justify-content: center;
      align-items: center;
    }
    .close-wrapper {
      position: absolute;
      top:0;
      right:0;
      left:0;
      display:flex;
      justify-content:right;
    }
    .form__group {
      position: relative;
      padding: 15px 0 0;
      margin-top: 10px;
      margin-bottom: 24px;
    }
    .form__field {
      font-family: inherit;
      width: 100%;
      border: 0;
      border-bottom: 1px solid #787878;
      outline: 0;
      font-size: 16px;
      color: #333333;
      padding: 7px 0;
      background: transparent;
      transition: border-color 0.2s;
    }
    .form__field::placeholder {
      color: transparent;
    }
    .form__field:placeholder-shown ~ .form__label {
      font-size: 16px;
      cursor: text;
      top: 20px;
    }
    label,
    .form__field:focus ~ .form__label {
      position: absolute;
      top: 0;
      display: block;
      transition: 0.2s;
      font-size: 12px;
      color: #787878;
    }
    .form__field:focus ~ .form__label {
      color: var(--main-color);
    }
    .form__field:focus {
      padding-bottom: 6px;
      border-bottom: 2px solid var(--main-color);
    }
    @keyframes spin {
      from {
        transform: rotate(0deg)
      }
      to {
        transform: rotate(360deg);
      }
    }
    .spinning {
      animation: spin 1.5s linear infinite;
    }
    input[type="url"] {
      text-transform: none;
    }
    .delete-notification-text {
      font-size: 16px;
      max-height: 18px;
      margin-top: 24px;
      margin-bottom: 24px;
    }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
  </head>
  <body>
    <script>

      (_ => {

        /**
         * A class for timing duration of things
         */
        class Timer {
          constructor(label) {
            if (label) this.label = label;
            this.startTime = new Date().getTime();
          }
          end() {
            var ms = new Date().getTime() - this.startTime;
            var seconds = ms / 1000;
            var hours = parseInt(seconds / 3600);
            seconds = seconds % 3600;
            var minutes = parseInt(seconds / 60);
            seconds = seconds % 60;
            return [
              hours,
              minutes,
              Number(seconds.toFixed(2)),
            ];
          }
          endString() {
            var endTime = this.end();
            let str = '';
            if (this.label) str += `${this.label}: `;
            if (endTime[0]) {
              str += `${endTime[0]} hours `;
            }
            if (endTime[1]) {
              str += `${endTime[1]} minutes `;
            }
            str += `${endTime[2]} seconds`;
            return str;
          }
        }
  
        /**
         * startup timer begin
         */
        const t = new Timer('start up');
  
        /**
         * HTMLElement has been clicked 
         */
        HTMLElement.prototype.onClick = function(cb) {
          this.addEventListener('click', cb, false);
        };
  
        /**
         * Query Selector
         * 
         * @param {String} selector
         * @param {Scope} scope
         * 
         * @returns {HTMLElement} 
         */
        function qs(selector, scope) {
          return (scope || document).querySelector(selector);
        }
  
        /**
         * Query Selector All
         * 
         * @param {String} selector
         * @param {Scope} scope
         * 
         * @returns {HTMLElement} 
         */
        function qsa(selector, scope) {
          return (scope || document).querySelectorAll(selector);
        }
  
        /**
         * user alert at top of screen
         * 
         * @param {String} message
         */
        async function alertUser(message) {
          qs('#alert-text').textContent = message;
          await sleep(20);
          await animateElement(qs('#alert'), 'translateY(0%)', 800, 1);
        }
  
        /**
         * wait an ammout of time
         * 
         * @param {ms} milliseconds
         * 
         * @returns {Promise<Void>} Nothing 
         */
        function sleep(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }
  
        /**
         * Overflow Toasts.
         * when more then one toast happens in a short period of time overflow will be pushed here
         */
        const _toastCache = [];
  
        /**
         * display a toast message
         *
         * @param {String} message - text to be displayed in the toast
         * @param {Number} _timeout - in seconds  || defualt 3.5 seconds  ** optional
         * @param {String} link - url to go to when toast is clicked
         * @param {String} linkText - yellow text
         */
        class Toast {
          constructor(message, _timeout, link, linkText) {
            // push toast to cache if currently displaying a toast
            if (qs('#toast')) {
              _toastCache.push([
                message,
                _timeout,
                link,
                linkText
              ]);
              return;
            }
            // bind this to internal functions
            this._transitionEnd = this._transitionEnd.bind(this);
            this._cleanUp = this._cleanUp.bind(this);
            this._clicked = this._clicked.bind(this);

            console.log(message);

            // create the toast
            this._timer = false;
            this._timeout = _timeout * 1000 || 3500;
            this.toast = this._createToast();
            if (link && linkText) {
              this.link = link;
              this.toast.appendChild(this._withLink(message, link, linkText));
            } else {
              this.toast.textContent = message;
            }
            qs('body').appendChild(this.toast);
            sleep(25).then(_ => requestAnimationFrame(_ => {
              this.toast.style.opacity = 1;
              this.toast.style.transform = 'translateY(0px)';
            }));
          }
  
          /**
           * returns a new toast html element
           * 
           * @returns {HTMLElement} hot toast
           */
          _createToast() {
            const toast = document.createElement('div');
            toast.id ='toast';
            toast.classList.add('toast');
            toast.style.opacity = 0;
            toast.style.transform = 'translateY(80px)';
            toast.style.willChange = 'auto';
            toast.style.transition = 'all 300ms cubic-bezier(.33,.17,.85,1.1) 0ms';
            toast.addEventListener(transitionEvent, this._transitionEnd, true);
            toast.onClick(this._clicked, true)
            return toast;
          }
  
          /**
           * butter in the toast with some link info
           * @param {String} message - text string
           * @param {String} link - URL
           * @param {String} linkText - text string
           * 
           * @returns {HTMLElement} link wrapper
           */
          _withLink(message, link, linkText) {
            
            var mText = document.createElement('div');
            mText.textContent = message;
            
            var lText = document.createElement('div');
            lText.textContent = linkText;
            lText.classList.add('yellow-text');
            
            const wrapper = document.createElement('div');
            wrapper.style.display = 'flex';
            wrapper.style.justifyContent = 'space-between';
            wrapper.style.alignItems = 'center';
            wrapper.style.overflow = 'none';
            [mText, lText].forEach(el => wrapper.appendChild(el));
            return wrapper;
          }
  
          /**
           * event handler for toast click
           */
          _clicked() {
            if (this.link) {
              window.open(this.link, "_blank");
            }
            this._cleanUp();
          }
  
          /**
           * play closing animation and remove element from document
           */
          _cleanUp() {
            if (this._timer) {
              clearTimeout(this._timer);
              this._timer = false;
            }
            this.toast.addEventListener(transitionEvent, _ => {
              if (this.toast) {
                this.toast.remove();
              }
            });
            requestAnimationFrame(_ => {
              this.toast.style.opacity = 0;
              this.toast.style.transform = 'translateY(80px)';
            });
          }
  
          /**
           * called after opening animation
           * sets up closing animation
           */
          _transitionEnd() {
            this._timer = setTimeout(this._cleanUp, this._timeout);
            this.toast.removeEventListener(transitionEvent, this._transitionEnd);
          }
        }
  
        /**
         * determine what transition event to listen for
         * 
         * @returns {String} transition event name
         */
        function whichTransitionEvent() {
          let t;
          const el = document.createElement('fakeelement');
          const transitions = {
            'MozTransition':'transitionend',
            'WebkitTransition':'webkitTransitionEnd',
            'MSTransition':'msTransitionEnd',
            'OTransition':'oTransitionEnd',
            'transition':'transitionEnd'
          };
          for (event in transitions) {
            if (el.style[event] !== undefined ) {
              return transitions[event];
            }
          }
        }
  
        // the browser transition event name
        const transitionEvent = whichTransitionEvent();
        console.log(`transition event: ${transitionEvent}`);

        /**
         * animate transform of transform and opacity on a HTML element
         *
         * @param {HTMLElement} el the HTML element to be animated *required*
         * @param {String} transform transform value *required*
         * @param {Number} time duration the animation will take to play through *optional*
         * @param {Number} opacity opacity value *optional*
         * @param {Number} delay time to wait before animating *optional*
         * 
         * @returns {Promise<Void>} nothing
         * 
         * @example <caption>Example usage of animateElement() function.</caption>
         * animateElement(card, 'translateX(0)', 200, 1).then(_ => {
         * // animation complete
         * });
         */
        function animateElement(el, transform, time, opacity, delay) {
          return new Promise(resolve => {
            if (!el) {
              console.error(`${el} does not exist`);
              resolve();
              return; 
            }
            if (el.style.transform === transform) {
              resolve();
              return;
            }
            var t = 0;
            const animationEnd = _ => {
              if (t) {
                clearTimeout(t);
                t = 0;
              }
              el.removeEventListener(transitionEvent, animationEnd);
              el.style.removeProperty('will-change');
              el.style.removeProperty('transition');
              resolve();
            };
            if (!time) {
              time = 300;
            }
            if (!delay) {
              delay = 0;
            }
            el.addEventListener(transitionEvent, animationEnd, true);
            el.style.willChange = 'auto';
            el.style.transition = `all ${time}ms cubic-bezier(.33,.17,.85,1.1) ${delay}ms`;
            requestAnimationFrame(_ => {
              el.style.transform = transform;
              if (opacity !== undefined) {
                el.style.opacity = opacity;
              }
              t = setTimeout(animationEnd, time + 10);
            });
          });
        }
  
        /**
         * fade in opacity of a given element
         *
         * @param {HTMLElement} el HTML element to fade
         * @param {Number} time duration of the fade animation
         * 
         * @returns {Promise<Void>} nothing
         * 
         * @example <caption>Example usage of fadeIn() function.</caption>
         * fadeIn(card, 200).then(_ => {
         * // animation complete
         * });
         */
        function fadeIn(el, time) {
          return new Promise(resolve => {
            if (!el) {
              return resolve();
            }
            if (el.style.opacity === 1) {
              return resolve();
            }
            if (!time) {
              time = 200;
            }
            var t = 0;
            const animationEnd = _ => {
              if (t) {
                clearTimeout(t);
                t = 0;
              }
              el.removeEventListener(transitionEvent, animationEnd);
              el.style.removeProperty('will-change');
              el.style.removeProperty('transition');
              resolve();
            };
            el.addEventListener(transitionEvent, animationEnd, true);
            el.style.willChange = 'opacity';
            el.style.transition = `opacity ${time}ms cubic-bezier(.33,.17,.85,1.1) 0s`;
            requestAnimationFrame(_ => {
              el.style.opacity = 1;
              t = setTimeout(animationEnd, time + 10);
            });
          });
        }
  
        /**
         * fade out opacity of a given element
         *
         * @param {HTMLElement} el HTML element to fade
         * @param {Number} time duration of the fade animation
         * 
         * @returns {Promise<Void>} nothing
         * 
         * @example <caption>Example usage of fadeOut() function.</caption>
         * fadeOut(card, 200).then(_ => {
         * // animation complete
         * });
         */
        function fadeOut(el, time) {
          return new Promise(resolve => {
            if (!el) {
              return resolve();
            }
            if (el.style.opacity === 0) {
              return resolve();
            }
            if (!time) {
              time = 200;
            }
            var t = 0;
            var animationEnd = _ => {
              if (t) {
                clearTimeout(t);
                t = 0;
              }          
              el.removeEventListener(transitionEvent, animationEnd);
              el.style.removeProperty('will-change');
              el.style.removeProperty('transition');
              resolve();
            };
            el.addEventListener(transitionEvent, animationEnd, true);
            el.style.willChange = 'opacity';
            el.style.transition = `opacity ${time}ms cubic-bezier(.33,.17,.85,1.1) 0s`;
            requestAnimationFrame(_ => {
              el.style.opacity = 0;
              t = setTimeout(animationEnd, time + 10);
            });
          });
        }
  
        /**
         * animate transform / opacity on a give element
         *
         * @param {HTMLElement} el HTML element *required*
         * @param {String} height height value *required*
         * @param {Number} time duration for the animation to complete
         * 
         * @returns {Promise<void>}
         */
        function animateHeight(el, height, time) {
          return new Promise(resolve => {
            if (!el) {
              return resolve();
            }
            var t = 0;
            const animationEnd = _ => {
              if (t) {
                clearTimeout(t);
                t = 0;
              }
              el.removeEventListener(transitionEvent, animationEnd);
              el.style.removeProperty('will-change');
              el.style.removeProperty('transition');
              resolve();
            };
            if (!time) {
              time = 300;
            }
            el.addEventListener(transitionEvent, animationEnd, true);
            el.style.willChange = 'height';
            el.style.transition = `height ${time}ms cubic-bezier(.33,.17,.85,1.1) 0s`;
            requestAnimationFrame(_ => {
              el.style.height = height;
              t = setTimeout(animationEnd, time + 10);
            });
          });
        }
  
        /**
         * returns the height of the heml element
         * 
         * @param {Element} el - html 
         * 
         * @returns {Number} height of the given element
         */
        function elementHeight(el) {
          let elHeight = el.offsetHeight;
          elHeight += parseInt(window.getComputedStyle(el).getPropertyValue('margin-top'));
          elHeight += parseInt(window.getComputedStyle(el).getPropertyValue('margin-bottom'));
          return elHeight;
        }
  
        /**
         * triggers a ripple effect in a clicked element
         * 
         * @param (Event) event - click event
         * 
         * @returns {nothing}
         */    
        async function createRipple(event) {
          const button = event.currentTarget;
          const diameter = Math.max(button.clientWidth, button.clientHeight);
          const radius = diameter / 2;

          const circle = document.createElement("span");
          circle.style.width = circle.style.height = `${diameter}px`;
          circle.style.left = `${event.clientX - button.offsetLeft - radius}px`;
          circle.style.top = `${event.clientY - button.offsetTop - radius}px`;
          ['ripple', 'ripple-effect'].forEach(cssClass => circle.classList.add(cssClass));

          button.appendChild(circle);

          await sleep(600);
          const ripple = qs(".ripple-effect", button);
          if (ripple) {
            ripple.remove();
          }
        }

        /**
         * creates an SVG icon 
         * 
         * @param {String} d
         * @param {Boolean} viewbox
         * @param {String} color
         * 
         * @returns {HTMLElement} SVG ICON
         */
        function svgIcon(d, viewbox, color) {
          if (!viewbox) viewbox = false;

          const path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
          path.setAttribute("d", d);
          if (color) {
            path.setAttribute('fill', color);
          } else {
            path.setAttribute('fill', 'currentColor');
          }
          
          const svg = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
          svg.appendChild(path);
          if (viewbox) svg.setAttribute('viewBox', "0 -960 960 960");
          return svg;
        }
  
        /**
         * validate URL
         * 
         * @param {String} url
         * 
         * @returns {Boolean}
         */
        function isValidURL(url) {
          const urlRegex = /^(ftp|http|https):\/\/[^ "]+$/;
          return urlRegex.test(url);
        }

        /**
         * displays the music library in a selectable form
         */
        class MusicLibrary extends HTMLElement {
          constructor() {
            super();
            this._makeSelection = this._makeSelection.bind(this);
            this._displayArtist = this._displayArtist.bind(this);
            const style = document.createElement('style');
            style.textContent = `
              @keyframes ripple-animation {
                to {
                  transform: scale(2);
                  opacity: 0;
                }
              }
              div:first-child {
                border-top: none;
              }
              .ripple {
                position: relative;
                overflow: hidden;
                transform: translate3d(0, 0, 0);
              }
              .ripple-effect {
                position: absolute;
                border-radius: 50%;
                background: rgba(125, 125, 125, 0.4);
                animation: ripple-animation 0.7s linear;
              }
              .artist {
                position: relative;
                border-top: 1px solid #3333333d;
                cursor: pointer;
                padding: 8px;
                font-size: 17px;
                font-weight: bold;
                overflow: hidden;
              }
              .artist:hover {
                background-color: var(--hover-color);
              }
              .album {
                position: relative;
                border-top: 1px solid #3333333d;
                cursor: pointer;
                padding: 4px;
                font-size: 13px;
                overflow: hidden;
              }
              .album:hover {
                background-color: var(--hover-color);
              }
              .album.selected {
                background-color: rgba(100, 100, 100, 0.582);
              }
              .album.selected:hover {
                background-color: #00000044;
              }
              .blank {
                height: 550px;
                display: flex;
                align-items: center;
                justify-content: center;
              } 
            `;
            this.content = document.createElement('div');
            this.shadow = this.attachShadow({mode: "open"});
            [
              style, 
              this.content
            ].forEach(el => this.shadow.appendChild(el));
          }
  
          /**
           * fetch data
           */
          async go() {
            await fadeOut(this.content);
            this.content.innerHTML = '';
            const library = await pywebview.api.lib_data();
            this.libSize = library.lib_size || '0 b';
            delete library.lib_size;
            this._displayData(library);
            const syncData = await pywebview.api.sync_file()
            this._compareData(syncData);
            fadeIn(this.content);
          }
  
          /**
           * fill in page with data
           * 
           * @param {Object} data artists and albums list from lib_data.json *required*
           */
          _displayData(data) {
            if (Object.keys(data).length === 0) {
              this._emptyLib();
              return;
            }
            for (const artist in data) {
              this._displayArtist(artist);
              for (let i = 0; i < data[artist].length; i++) {
                this._displayAlbum(artist, data[artist][i]);
              }
            }
          }
  
          /**
           * fired when ther is no lib_data.json file
           */
          _emptyLib() {
            // empty library notification
            alertUser('Click the Scan button to load library');
            
            // UI buttons that will be disabled
            const buttons = [
              '#menu-button',
              '#settings',
              'audiosync-tabs'
            ]
            buttons.forEach(id => qs(id).setAttribute('disabled', 1));
              
            // scan library button
            const button = document.createElement('audiosync-button');
            button.textContent = 'Scan Music';
            
            // wrapper to place content
            const wrapper = document.createElement('div');
            wrapper.classList.add('blank');
            wrapper.appendChild(button);

            button.onClick(async _ => {

              new Toast('Scan can take some time to complete', 10);
              // hide the button
              await fadeOut(button);

              // remove the button once hidden
              wrapper.innerHTML = '';

              // progress bar label
              const label = document.createElement('div');
              label.textContent = 'Building Library';

              //  progress percentage text
              const percent = document.createElement('div');
              percent.textContent = '0%';

              // create progress bar
              this.bar = document.createElement('audiosync-progress');
              this.bar.style.opacity = 0;
              this.bar.style.width = '90%';
              [
                label,
                percent
              ].forEach(el => this.bar.appendChild(el));

              // add the bar to the UI in a hidden state
              wrapper.appendChild(this.bar);
              this.percent = percent;
              await sleep(10);

              //  uphide the progress bar
              await fadeIn(this.bar);
              const t = new Timer('Initial Scan');

              // do the scan actual in python
              await pywebview.api.create_json();

              // scan finished
              buttons.forEach(id => qs(id).removeAttribute('disabled'));
              const s = t.endString();
              new Toast(s);
            });
            this.content.appendChild(wrapper);
          }
  
          /**
           * update library scan progress bar
           * 
           * @param {Number} ndx - current position
           * @param {Number} length - total 
           */
          async updateBar(ndx, length) {
            const percent = ((ndx + 1) / length) * 100;
            this.bar.setAttribute('percent', percent);
            this.percent.textContent = `${percent.toFixed(1)}%`;
            if (percent === 100) {
              await fadeOut(this.bar);
              await sleep(100);
              await this.go();
              qs('audiosync-menu').footElement(this.libSize);
            }
          }
  
          /**
           * album element
           * 
           * @param {String} artist
           * @param {String} album
           */
          _displayAlbum(artist, album) {
            let albumContainer = document.createElement('div');
            albumContainer.dataset.artist = artist;
            albumContainer.dataset.album = album;
            albumContainer.classList.add('album');
            albumContainer.textContent = album;
            albumContainer.onClick(this._makeSelection);
            this.content.appendChild(albumContainer);
          }
  
          /**
           * artist element
           * 
           * @param {String} artist
           */
          _displayArtist(artist) {
            let artistContainer = document.createElement('div');
            artistContainer.dataset.artist = artist;
            artistContainer.classList.add('artist');
            artistContainer.textContent = artist;
            artistContainer.onClick(this._makeSelection);
            this.content.appendChild(artistContainer);
          }
  
          /**
           * compares sync.json data to lib_data.json data selects all elements listed in sync.json
           * 
           * @param {Object} data
           */
          _compareData(data) {
            if (Object.keys(data).length === 0) {
              const s = 'No sync file... Running sync now will sync all music';
              console.log(s);
              alertUser(s);
              return;
            }
            for (const artist in data) {
              const m = qsa(`[data-artist="${artist}"].artist`, this.shadow);
              m.forEach(el => el.classList.add('selected'));
              for (let i=0; i < data[artist].length; i++) {
                const s = qsa(`[data-album="${data[artist][i]}"]`, this.shadow);
                s.forEach(el => el.classList.add('selected'));
              }
            }
          }
  
          /**
           * creates a new object from selected elements to be saved as sync.json
           */
          buildObject() {
            const artistAlbums = {};
            // Select all elements with the data-artist attribute
            const artistElements = qsa('.selected', this.shadow);
            // Iterate over each artist element
            artistElements.forEach(artistElement => {
              const artistName = artistElement.dataset.artist;
              // If the artist name is not in the object, initialize an empty array for their albums
              if (!(artistName in artistAlbums)) {
                artistAlbums[artistName] = [];
              }
              const albumName = artistElement.dataset.album;
              if (!(albumName in artistAlbums[artistName]) && albumName != null) {
                artistAlbums[artistName].push(albumName);
              }
            });
            return artistAlbums;
          }
  
          /**
           * element has been clicked on
           * 
           * @param {Event} e
           */
          _makeSelection(e) {
            createRipple(e);
            const target = e.target;
            target.classList.toggle('selected');
            if (target.classList.contains('artist')) {
              const matchingArtist = qsa(`[data-artist="${target.dataset.artist}"]`, this.shadow);
              matchingArtist.forEach(el => {
                if (target.classList.contains('selected')) {
                  el.classList.add('selected');
                } else {
                  el.classList.remove('selected');
                } 
              });
            }
            if (target.classList.contains('album')) {
              const matchingArtist = qsa(`[data-artist="${target.dataset.artist}"].artist`, this.shadow);
              matchingArtist.forEach(el => {
                if (target.classList.contains('selected')) {
                  el.classList.add('selected');
                } else {
                  el.classList.remove('selected');
                } 
              });
            }
          }
        }
        customElements.define('music-library', MusicLibrary);
  
        /**
         * scroll area with a back to top action button
         */
        class ScrollElement extends HTMLElement {
          constructor() {
            super();
            this.animateScroll = this.animateScroll.bind(this)
            const sheet = document.createElement('style');
            sheet.textContent = `
              @keyframes ripple-animation {
                to {
                  transform: scale(2);
                  opacity: 0;
                }
              }
              .ripple {
                position: relative;
                overflow: hidden;
                transform: translate3d(0, 0, 0);
              }
              .ripple-effect {
                position: absolute;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.4);
                animation: ripple-animation 0.7s linear;
              }
              .wrapper {
                position: fixed;
                will-change: auto;
                top: var(--header-height);
                left: 0;
                right: 0;
                bottom: 0;
                overflow: auto;
                overflow-x: hidden;
                padding:8px;
                -webkit-overflow-scrolling: touch;
                text-align: center;
                background: var(--background-color);
                scroll-behavior: smooth;
              }
              .wrapper::-webkit-scrollbar {
                width: 0; /* Hide scrollbar */
              }
              .fab {
                overflow: hidden;
                background: var(--main-color);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                box-sizing: border-box;
                color: var(--text-color);
                cursor: pointer;
                height: 56px;
                min-width: 0;
                outline: none;
                padding: 16px;
                position: fixed;
                right: 20px;
                bottom: 20px;
                width: 56px;
                -webkit-tap-highlight-color: transparent;
                box-shadow:0 4px 5px 0 rgba(0,0,0,0.14),0 1px 10px 0 rgba(0,0,0,0.12),0 2px 4px -1px rgba(0,0,0,0.4);
                z-index: 2;
              }
              .fab:after {
                display: inline-block;
                z-index: -1;
                width: 100%;
                height: 100%;
                opacity: 0;
                border-radius: 50%;
                transition: opacity 150ms cubic-bezier(.33,.17,.85,1.1);
                box-shadow: 0 8px 10px 1px rgba(0,0,0,.14), 0 3px 14px 2px rgba(0,0,0,.12), 0 5px 5px -3px rgba(0,0,0,.4);
                content:' ';
                position: absolute;
                top: 0;
                left: 0;
              }
              .fab:hover:after {
                opacity: 1;
              }
              .fab:hover:active:after {
                opacity: 0;
              }
              svg {
                width:24px;
                height:24px;
                display: flex;
              }
            `;
            // action button animation time
            const animateTime = 200;
  
            // scroll position memory
            let last_top = 0;
  
            // floating action button
            const svg = svgIcon(
              "M15,20H9V12H4.16L12,4.16L19.84,12H15V20Z", 
              false
            );

            const fab = document.createElement('div');
            fab.appendChild(svg);
            fab.classList.add('fab');
            fab.style.transform = 'translateY(80px)';
            fab.onClick(e => {
              createRipple(e);
              this.animateScroll();
            });
  
            // content body
            this.content = document.createElement('div');
            this.content.appendChild(document.createElement('slot'));
  
            // scrollable content container
            this.container = document.createElement('div');
            this.container.classList.add('wrapper');
            this.container.onscroll = e => {
              // no action button on podcasts (animation bug)
              const currentPage = qs('audiosync-pages').getAttribute('selected');
              if (currentPage > 0 ) return;

              // control action button
              const scrollTop = this.container.scrollTop;
              if (scrollTop < last_top) {
                animateElement(fab, "translateY(80px)", animateTime);
              } else if (scrollTop != 0) {
                animateElement(fab, "translateY(0px)", animateTime);
              } else {
                animateElement(fab, "translateY(80px)", animateTime);
              }
              last_top = scrollTop;
            };
            [
              this.content,
              fab
            ].forEach(el => this.container.appendChild(el));
            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              this.container
            ].forEach(el => shadow.appendChild(el));
          }
  
          /**
           * converts 1 number range to be in another number's range
           * 
           * @param {Number} value
           * @param {Number} low1
           * @param {Number} low2
           * @param {Number} high1
           * @param {Number} high2
           * 
           * @returns {Number} number in the new range
           */
          _mapRange(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
          }
  
          /**
           * animate scroll to top of the page
           * moves content down the page and when content reaches what would be the top position the page snaps back into original position
           * 
           * @returns {Promise<Void>} Nothing
           */
          animateScroll() {
            return new Promise(async resolve => {
              const maxScrollTop = Math.max(
                this.container.scrollHeight - this.container.clientHeight,
                0
              );
              // set animation time based on distance scrolled down the page
              const time = this._mapRange((this.container.scrollTop / maxScrollTop), 0, 1, 100, 600);
              await animateElement(this.content, `translateY(${this.container.scrollTop}px)`, time);
              this.content.style.removeProperty('transform');
              this.container.scrollTop = 0;
              resolve();
            });
          }
        }
        customElements.define('scroll-element', ScrollElement);
  
        /**
         * menu drawer element
         */
        class AudioSyncMenu extends HTMLElement {
          constructor() {
            super();
            this.open = this.open.bind(this);
            this.close = this.close.bind(this);
            const sheet = document.createElement('style');
            sheet.textContent = `
              .allow-clicks {
                pointer-events: none;
                display: none;
              }
              #click-blocker {
                position: absolute;
                top:0;
                bottom:0;
                left:0;
                right:0;
                background-color: rgba(0, 0, 0, 0.2);
                pointer-events: all;
                z-index:1;
              }
              .wrapper {
                position: fixed;
                will-change: auto;
                top:128px;
                left:0;
                right:0;
                height: 100%;
                overflow: auto;
                overflow-x: hidden;
                padding: 0px;
                -webkit-overflow-scrolling: touch;
                text-align: center;
              }
              header {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 128px;
                background-color: var(--main-color);
                color: var(--text-color);
                will-change: auto;
              }
              .header-content {
                padding: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
              }
              .header-shadow {
                height: 6px;
                box-shadow: inset 0px 5px 6px -3px rgba(0,0,0,0.4);
                position: absolute;
                will-change: auto;
                top: 128px;
                left: 0;
                right: 0;
                pointer-events: none;
                z-index: 1;
              }
              .menu {
                position: absolute;
                top:0;
                bottom:0;
                left:0;
                width: 300px;
                background-color: #ffffff;
                color: var(--text-color);
                z-index: 2;
                transform: translateX(-320px);
                box-shadow: 10px 0 0px rgba(0, 1, 0, 0.1);
              }
              .menu-foot {
                bottom: 0;
                left:0;
                right:0;
                position: absolute;
              }
              .menu-button {
                padding: 12px;
                display: flex;
                color: #333333;
                justify-content: space-between;
                align-items: center;
                font-size: 16px;
                border-top: 1px solid #3333333d;
                position: relative;
                overflow: hidden;
              }
              .menu-button div {
                width: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                text-transform: uppercase;
              }
              svg {
                width:24px;
                height:24px;
                display: flex;
              }
            `;
            // blocks clicks from background elements
            this.blocker = document.createElement('div');
            this.blocker.id = 'click-blocker';
            this.blocker.classList.add('allow-clicks');
            this.blocker.onClick(this.close);

            //  menu header
            const headerContent = document.createElement('div');
            headerContent.classList.add('header-content');
            
            const header = document.createElement('header'); 
            header.appendChild(headerContent);
            
            const headerShadow = document.createElement('div');
            headerShadow.classList.add('header-shadow')
            
            //  scrollable section 
            const wrapper = document.createElement('div');
            wrapper.classList.add('wrapper');
            wrapper.appendChild(document.createElement('slot'));
            
            this.foot = document.createElement('div');
            this.foot.classList.add('menu-foot');
            
            this.menu = document.createElement('div');
            this.menu.classList.add('menu');
            [
              header,
              headerShadow,
              wrapper,
              this.foot
            ].forEach(el => this.menu.appendChild(el));

            const shadow = this.attachShadow({
              mode: "open"
            });
            [
              sheet,
              this.blocker,
              this.menu
            ].forEach(el => shadow.appendChild(el));
          }
  
          /**
           * element connected to DOM
           */
          connectedCallback() {
            this.setAttribute('opened', 0);
          }
  
          /**
           * open menu drawer
           */
          async open() {
            fadeIn(this.blocker);
            this.blocker.classList.remove('allow-clicks');
            await animateElement(this.menu, `translateX(0px)`, 250);
            this.setAttribute('opened', 1);
          }
  
          /**
           * close menu drawer
           */
          async close() {
            fadeOut(this.blocker);
            await animateElement(this.menu, `translateX(-320px)`, 250);
            this.blocker.classList.add('allow-clicks');
            this.setAttribute('opened', 0);
          }
  
          /**
           * adds a elements to footer of 
           * 
           * @param {String} text 
           */
          footElement(text) {
            // floppy disk icon
            const icon = 'M840-680v480q0 33-23.5 56.5T760-120H200q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h480l160 160Zm-80 34L646-760H200v560h560v-446ZM480-240q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35ZM240-560h360v-160H240v160Zm-40-86v446-560 114Z';
  
            // empty the footer
            this.foot.innerHTML = '';
            
            const fsText = document.createElement('div');
            fsText.textContent = `music: ${text}`;
            
            const dummyButton = document.createElement('div');
            [
              svgIcon(icon, true),
              fsText
            ].forEach(el => dummyButton.appendChild(el));
            dummyButton.classList.add('menu-button');
                      
            this.foot.appendChild(dummyButton);
          }
        }
        customElements.define('audiosync-menu', AudioSyncMenu);
        
        /**
         * application header
         */
        class AudioSyncHeader extends HTMLElement {
          constructor() {
            super();
            const headerContent = document.createElement('div');
            headerContent.classList.add('header-content');
            headerContent.appendChild(document.createElement('slot'));
  
            const header = document.createElement('header'); 
            header.appendChild(headerContent);
  
            const headerShadow = document.createElement('div');
            headerShadow.classList.add('header-shadow')
  
            const sheet = document.createElement('style');
            sheet.textContent = `
              body {
                position: absolute;
                top:0
                top:0;
                bottom:0;
                left:0;
                right:0;
                background: var(--background-color);
                font-family: var(--font-family);
                font-size: 13px;
                -webkit-tap-highlight-color: rgba(0,0,0,0);
                user-select: none;
                overflow-x: hidden;
                overflow-y: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                padding:0;
                margin:0;
                color: var(--text-color);
              }
              header {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: var(--header-height);
                background-color: var(--main-color);
                color: var(--text-color);
                will-change: auto;
              }
              .header-content {
                padding: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
              }
              .header-shadow {
                height: 6px;
                box-shadow: inset 0px 5px 6px -3px rgba(0,0,0,0.4);
                position: absolute;
                will-change: auto;
                top: var(--header-height);
                left: 0;
                right: 0;
                pointer-events: none;
                z-index: 1;
              }
            `;
            const shadow = this.attachShadow({mode: "open"});
            [
              sheet, 
              header,
              headerShadow
            ].forEach(el => shadow.appendChild(el));
          }
        }
        customElements.define('audiosync-header', AudioSyncHeader);
  
        /**
         * application loading element
         */
        class AudioSyncLoader extends HTMLElement {
          constructor() {
            super();
            this.loader = document.createElement('div');
            this.loader.classList.add('load')
            this.loader.appendChild(document.createElement('slot'))
            const sheet = document.createElement('style');
            sheet.textContent = `
              .load {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgb(182, 182, 182);
                justify-content: center;
                display: flex;
                align-items: center;
                z-index:3;
                text-transform: uppercase;
                pointer-events: all;
                overflow: hidden;
                font-size: 1.5em;
                z-index: 8;
                color: #333333;
              }
            `;
            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              this.loader
            ].forEach(el => shadow.appendChild(el));
          }
  
          async reveal() {
            // reveals the app interface
            await animateElement(this.loader, `translateY(-${elementHeight(this.loader)}px) `, 350);
            // fixes any height issues when resizing the window
            window.addEventListener('resize', _ => {
              this.loader.style.transform = `translateY(-${elementHeight(this.loader)}px)`;
            });
          }
        }
        customElements.define('audiosync-loader', AudioSyncLoader);
      
        /**
         * pretty button
         */
        class AudioSyncButton extends HTMLElement {
          static get observedAttributes() {
            return ['color', 'disabled', 'noshadow'];
          }
          constructor() {
            super();
            // color higherarchy 
            // color attribute > css '--main-color' variable > white
            const color = this._convertToHex(this.getAttribute('color') || this._getCSSVariableValue('--main-color') || '#ffffff');
            
            // contrasting text color 
            const contrast = this._getContrastColor(color);

            this.button = document.createElement('div');
            this.button.classList.add('button');
            this.button.appendChild(document.createElement('slot'));
            this.button.onClick(e => {
              // no ripple for disabled button
              if (this.button.hasAttribute('disabled')) return;
              this._createRipple(e) 
            });
            
            const sheet = document.createElement('style');
            sheet.textContent = `
            @keyframes ripple-animation {
              to {
                transform: scale(4);
                opacity: 0;
              }
            }
            .ripple {
              position: relative;
              overflow: hidden;
              transform: translate3d(0, 0, 0);
            }
            body {
              position: absolute;
              top:0;
              bottom:0;
              left:0;
              right:0;
              background: var(--background-color);
              font-family: var(--font-family);
              font-size: 13px;
              -webkit-tap-highlight-color: rgba(0,0,0,0);
              user-select: none;
              overflow-x: hidden;
              overflow-y: hidden;
              display: flex;
              justify-content: center;
              align-items: center;
              padding:0;
              margin:0;
            }
            .button {
              display: inline-flex;
              min-width: 5.14em;
              margin: 0.29em 0.29em;
              color: ${contrast};
              background-color: ${color};
              text-align: center;
              text-transform: uppercase;
              outline-width: 0;
              border-radius: 3px;
              padding: 0.7em 0.57em;
              cursor: pointer;
              position: relative;
              box-sizing:border-box;
              box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14),0 1px 5px 0 rgba(0,0,0,0.12),0 3px 1px -2px rgba(0,0,0,0.2);
              -webkit-user-select: none;
              user-select: none;
              pointer-events: all;
              justify-content: center;
              align-items: center;
              transition: background-color 0.45s ease;
              overflow: hidden;
            }
            .button > * {
              pointer-events: none;
            }
            .button:after {
              display: inline-block;
              width: 100%;
              height: 100%;
              border-radius: 3px;
              opacity: 0;
              transition: opacity 150ms cubic-bezier(.33,.17,.85,1.1);
              box-shadow: 0 8px 10px 1px rgba(0,0,0,.14), 0 3px 14px 2px rgba(0,0,0,.12), 0 5px 5px -3px rgba(0,0,0,.4);
              content:' ';
              position: absolute;
              top: 0;
              left: 0;
            }
            .button:hover:after {
              opacity: 1;
            }
            .button:hover:active:after {
              opacity: 0;
            }
            .button[disabled] {
              background: rgba(84, 84, 84, 0.4);
              color: #ffffff;
              box-shadow: none;
              cursor: none;
              pointer-events: none;
            }
            .button[disabled]:active, .button[disabled]:hover, .button[disabled]:active:hover {
              box-shadow: none;
              background-color: rgba(0, 0, 0, 0.178)
            }
            .button[noshadow], .button[noshadow]:hover, .button[noshadow]:hover:after, .button[noshadow]:after {
              box-shadow: none;
            }
            .button[noshadow]:active {
              box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14),0 1px 5px 0 rgba(0,0,0,0.12),0 3px 1px -2px rgba(0,0,0,0.2);
            }
            .ripple-effect {
              position: absolute;
              border-radius: 50%;
              background: ${this._hexToRgba(contrast)};
              animation: ripple-animation 0.7s linear;
            }`;

            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              this.button
            ].forEach(el => shadow.appendChild(el));
          }
  
          /**
           * element connected to DOM
           */
          connectedCallback() {
            if (this.hasAttribute('disabled')) {
              this.button.setAttribute('disabled', Number(this.getAttribute('disabled')));
            }
            if (this.hasAttribute('noshadow')) {
              this.button.setAttribute('noshadow', Number(this.getAttribute('noshadow')));
            }
          }

          /**
           * returns value of a css variable
           * 
           * @param {String} variableName
           * 
           * @return {String}
           */
          _getCSSVariableValue(variableName) {
            // Get the computed style of the document root
            var rootStyles = getComputedStyle(document.documentElement);
            // Use getProperty() method to get the value of the variable
            var value = rootStyles.getPropertyValue(variableName);
            return value.trim(); // Trim the value to remove any leading or trailing whitespace
          }

          /**
           * find and remove .new-color and .ripple-effect css classes
           * 
           * @param {Regex} regex
           * @param {String} cssString
           * 
           * @returns {String} css without the class if found by given regex (not a great function)
           */
          _removeClasses(cssString) {
             // Define a regular expression to match the entire block containing .new-color class and .ripple-effect class with their properties
            var regex = /\.new-color\s*{[^}]*}|\.ripple-effect\s*{[^}]*}/g;
            // Use replace method with the regular expression to remove the entire block
            var newCssString = cssString.replace(regex, '');
            return newCssString;
          }

          /**
           * creates a ripple animation on the button when clicked
           * 
           * @param {Event} event
           */
          async _createRipple(event) {
            const button = event.currentTarget;
            const diameter = Math.max(button.clientWidth, button.clientHeight);
            const radius = diameter / 2;

            const circle = document.createElement("span");
            circle.style.width = circle.style.height = `${diameter}px`;
            circle.style.left = `${event.clientX - button.offsetLeft - radius}px`;
            circle.style.top = `${event.clientY - button.offsetTop - radius}px`;
            ['ripple', 'ripple-effect'].forEach(cssClass => circle.classList.add(cssClass));

            button.appendChild(circle);

            await sleep(600);
            const ripple = qs(".ripple-effect", button);
            if (ripple) {
              ripple.remove();
            }
          }

          /**
           * convers hex to rgba
           * 
           * @param {String} hex
           * 
           * @returns {String} rgba color
           */
          _hexToRgba(hex) {
            // Remove # if present
            hex = hex.replace(/^#/, '');

            // Parse hex values
            var bigint = parseInt(hex, 16);

            // Extract RGB components
            var r = (bigint >> 16) & 255;
            var g = (bigint >> 8) & 255;
            var b = bigint & 255;

            // Return RGB as an object
            return `rgba(${r},${g},${b}, 0.4)`;
          }

          /**
           * convers text color ot RGB color to hex 
           * 
           * @param {String} color
           * 
           * @returns {String} HEX color code 
           */
          _convertToHex(color) {
            // If color is already in hex format or not a string, return it as is
            if (typeof color !== 'string' || /^#(?:[0-9a-fA-F]{3}){1,2}$/.test(color)) {
              return color;
            }
            
            // Check if color is a named color
            var tempElem = document.createElement('div');
            tempElem.style.color = color;
            document.body.appendChild(tempElem);
            var computedColor = window.getComputedStyle(tempElem).color;
            document.body.removeChild(tempElem);
            if (/^rgb/.test(computedColor)) {
              // Convert RGB to hex
              var rgbArray = computedColor.match(/\d+/g).map(function(num) {
                return parseInt(num, 10);
              });
              return '#' + rgbArray.map(function(num) {
                return ('0' + num.toString(16)).slice(-2);
              }).join('');
            } else {
              // Color is not a named color
              return color;
            }
          }

          /**
           * returns contrasting color to input hex code (thanks ChatGPT) =D
           * 
           * @param {String} hexColor hex color code
           * 
           * @returns {String} hex color code
           */
          _getContrastColor(hexColor) {
            // Convert hex color to RGB
            let r = parseInt(hexColor.substr(1, 2), 16);
            let g = parseInt(hexColor.substr(3, 2), 16);
            let b = parseInt(hexColor.substr(5, 2), 16);

            // Calculate the relative luminance
            let luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;

            // Return contrasting color based on luminance
            return luminance > 0.5 ? "#333333" : "#FFFFFF";
          }
  
          /**
           * create a rendom color code
           * 
           * @returns {String} hex color code
           */
          generateRandomHexCode() {
            // Generate random integer between 0 and 16777215 (2^24 - 1)
            var randomInt = Math.floor(Math.random() * 16777215);
            
            // Convert integer to hexadecimal string
            var hexCode = randomInt.toString(16);

            // Pad with zeros if necessary to ensure 6 characters
            while (hexCode.length < 6) {
              hexCode = '0' + hexCode;
            }

            // Prepend '#' symbol
            hexCode = '#' + hexCode;

            return hexCode;
          }


          /**
           * attribute has changed 
           * 
           * @param {String} name
           * @param {Number} oldVal
           * @param {Number} newVal
           */
          attributeChangedCallback(name, oldVal, newVal) {
            if (name === 'color') {
              if (newVal === null) return;

              // capture current styles
              const currentStyle = this._removeClasses(qs('style', this.shadowRoot).textContent);

              // color in hex format
              const color = this._convertToHex(newVal);

              const contrast = this._getContrastColor(color);

              // create the new style 
              const newClasses = `
              .new-color {
                background-color:${color}; 
                color:${contrast};
              }
              .ripple-effect {
                position: absolute; 
                border-radius: 50%; 
                background: ${this._hexToRgba(contrast)}; 
                animation: ripple-animation 0.7s linear;
              }`;

              // update styles
              qs('style', this.shadowRoot).textContent = currentStyle.trim() + newClasses;         

              // set the new class
              this.button.classList.add('new-color');

            } else if (['disabled','noshadow'].includes(name)) {
              // reflect attribute changes to the button element
              if (Boolean(Number(newVal))) {
                this.button.setAttribute(name, Number(newVal));
              } else {
                this.button.removeAttribute(name);
              }
            }
          }
        }
        customElements.define('audiosync-button', AudioSyncButton);

        /**
         * application settings drawer
         */
        class AudioSyncSettings extends HTMLElement {
          constructor() {
            super();
            this.state = false;
            this.open = this.open.bind(this)
            this.close = this.close.bind(this)
            const sheet = document.createElement('style');
            sheet.textContent = `
              body {
                position: absolute;
                top:0;
                bottom:0;
                left:0;
                right:0;
                background: var(--background-color);
                font-family: var(--font-family);
                font-size: 13px;
                -webkit-tap-highlight-color: rgba(0,0,0,0);
                user-select: none;
                overflow-x: hidden;
                overflow-y: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                padding:0;
                margin:0;
                color: var(--text-color);
              }
              @keyframes ripple-animation {
                to {
                  transform: scale(2);
                  opacity: 0;
                }
              }
              .ripple {
                position: relative;
                overflow: hidden;
                transform: translate3d(0, 0, 0);
              }
              .ripple-effect {
                position: absolute;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.4);
                animation: ripple-animation 0.7s linear;
              }
              .settings {
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                overflow: auto;
                overflow-x: hidden;
                position: fixed;
                will-change: auto;
                z-index: 10;
                background-color: var(--background-color);
              }
              header {
                height: 65px;
                background-color: #ffffff;
              }
              .header-content {
                padding: 12px;
                display: flex;
                justify-content: right;
                align-items: center;
              }
              .header-shadow {
                height: 6px;
                box-shadow: inset 0px 5px 6px -3px rgba(0,0,0,0.4);
                position: absolute;
                will-change: auto;
                top: var(--header-height);
                left: 0;
                right: 0;
                pointer-events: none;
                z-index: 1;
              }
              svg {
                width:24px;
                height:24px;
                display: flex;
              }
              .wrapper {
                position: fixed;
                will-change: auto;
                top: var(--header-height);
                left: 0;
                right: 0;
                bottom: 0;
                overflow: auto;
                overflow-x: hidden;
                padding:8px;
                -webkit-overflow-scrolling: touch;
                text-align: center;
                background: var(--background-color);
              }
              .card {
                color: #333333;
                max-width: 675px;
                min-width: 280px;
                padding: 8px;
                background: #fff;
                position: relative;
                margin: auto;
                border-radius: 3px;
                margin-bottom: 8px;
                box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14),0 1px 5px 0 rgba(0,0,0,0.12),0 3px 1px -2px rgba(0,0,0,0.2);
                text-align: center;
                margin-bottom: 100px;
              }
              .small-button {
                padding: 8px;
                cursor: pointer;
                position: relative;
                border-radius: 50%;
              }
            `;
 
            const svg = svgIcon(
              "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z", 
              false, 
              'red'
            );

            const close = document.createElement('div');
            close.appendChild(svg);
            close.classList.add('small-button');
            close.onClick(e => {
              createRipple(e);
              this.close();
            
            });
            const headerContent = document.createElement('div');
            headerContent.classList.add('header-content');
            headerContent.appendChild(close);
            
            const header = document.createElement('header');
            header.appendChild(headerContent);
            
            const headerShadow = document.createElement('div');
            headerShadow.classList.add('header-shadow');
            
            const card = document.createElement('div');
            card.classList.add('card');
            card.appendChild(document.createElement('slot'));
            
            const wrapper = document.createElement('div');
            wrapper.classList.add('wrapper');
            wrapper.appendChild(card);
            
            this.drawer = document.createElement('div');
            this.drawer.classList.add('settings');
            [
              header,
              headerShadow,
              wrapper
            ].forEach(el => this.drawer.appendChild(el));

            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              this.drawer
            ].forEach(el => shadow.appendChild(el));

            window.addEventListener('resize', _ => {
              if (!Boolean(this.getAttribute('opened'))) this.drawer.style.transform = `translateY(${elementHeight(this.drawer)}px)`;
            });
          }
  
          /**
           * element connected to DOM
           */
          connectedCallback() {
            this.setAttribute('opened', 0);
            this.drawer.style.transform = `translateY(${elementHeight(this.drawer)}px)`;
          }
  
          /**
           * open the settings drawer
           */
          async open() {
            await animateElement(this.drawer, `translateY(0px) `, 250);
            this.setAttribute('opened', 1);
          }
  
          /**
           * close the settings drawer
           */
          async close() {
            await animateElement(this.drawer, `translateY(${elementHeight(this.drawer)}px) `, 250);
            this.setAttribute('opened', 0);
          }
        }
        customElements.define('audiosync-settings', AudioSyncSettings);
      
        /**
         * material design switch
         */
        class AudioSyncSwitch extends HTMLElement {
          constructor() {
            super();
            const sheet = document.createElement('style');
            sheet.textContent = `
              .audiosync-switch {
                z-index: 0;
                position: relative;
                display: inline-block;
                color: rgba(var(--pure-material-onsurface-rgb, 0, 0, 0), 0.87);
                font-family: var(--font-family);
                font-size: 16px;
                line-height: 1.5;
                width: 95%;
                margin: 8px;
              }
  
              /* Input */
              .audiosync-switch > input {
                appearance: none;
                -moz-appearance: none;
                -webkit-appearance: none;
                z-index: -1;
                position: absolute;
                right: 6px;
                top: -8px;
                display: block;
                margin: 0;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                background-color: rgba(var(--pure-material-onsurface-rgb, 0, 0, 0), 0.38);
                outline: none;
                opacity: 0;
                transform: scale(1);
                pointer-events: none;
                transition: opacity 0.3s 0.1s, transform 0.2s 0.1s;
              }
  
              /* Span */
              .audiosync-switch > span {
                display: inline-block;
                width: 100%;
                cursor: pointer;
                text-transform: uppercase;
              }
  
              /* Track */
              .audiosync-switch > span::before {
                content: "";
                float: right;
                display: inline-block;
                margin: 5px 0 5px 10px;
                border-radius: 7px;
                width: 36px;
                height: 14px;
                background-color: rgba(var(--pure-material-onsurface-rgb, 0, 0, 0), 0.38);
                vertical-align: top;
                transition: background-color 0.2s, opacity 0.2s;
              }
  
              /* Thumb */
              .audiosync-switch > span::after {
                content: "";
                position: absolute;
                top: 2px;
                right: 16px;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                background-color:rgb(var(--pure-material-onprimary-rgb, 255, 255, 255));
                box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
                transition: background-color 0.2s, transform 0.2s;
              }
  
              /* Checked */
              .audiosync-switch > input:checked {
                right: -10px;
                background-color: rgb(var(--switch-rgb, 33, 150, 243));
              }
  
              .audiosync-switch > input:checked + span::before {
                background-color: rgba(var(--switch-rgb, 33, 150, 243), 0.6);
              }
  
              .audiosync-switch > input:checked + span::after {
                background-color: rgb(var(--switch-rgb, 33, 150, 243));
                transform: translateX(16px);
              }
  
              /* Hover, Focus */
              .audiosync-switch:hover > input {
                opacity: 0.04;
              }
  
              .audiosync-switch > input:focus {
                opacity: 0.12;
              }
  
              .audiosync-switch:hover > input:focus {
                opacity: 0.16;
              }
  
              /* Active */
              .audiosync-switch > input:active {
                opacity: 1;
                transform: scale(0);
                transition: transform 0s, opacity 0s;
              }
  
              .audiosync-switch > input:active + span::before {
                background-color: rgba(var(--switch-rgb, 33, 150, 243), 0.6);
              }
  
              .audiosync-switch > input:checked:active + span::before {
                background-color: rgba(var(--pure-material-onsurface-rgb, 0, 0, 0), 0.38);
              }
  
              /* Disabled */
              .audiosync-switch > input:disabled {
                opacity: 0;
              }
  
              .audiosync-switch > input:disabled + span {
                color: rgb(var(--pure-material-onsurface-rgb, 0, 0, 0));
                opacity: 0.38;
                cursor: default;
              }
  
              .audiosync-switch > input:disabled + span::before {
                background-color: rgba(var(--pure-material-onsurface-rgb, 0, 0, 0), 0.38);
              }
  
              .audiosync-switch > input:checked:disabled + span::before {
                background-color: rgba(var(--switch-rgb, 33, 150, 243), 0.6);
              }
            `;

            this.input = document.createElement('input');
            this.input.type = 'checkbox';

            const span = document.createElement('span');
            span.appendChild(document.createElement('slot'));

            const label = document.createElement('label');
            label.classList.add('audiosync-switch');
            [
              this.input,
              span
            ].forEach(el => label.appendChild(el));
            
            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              label
            ].forEach(el => shadow.appendChild(el));
  
            this.input.onchange = async _ => {
  
              this.setAttribute('state', Number(this.input.checked));
  
              // state of the settings switches
              const states = { 
                import_cues: qs('#cues').state(),
                import_lyrics: qs('#lyrics').state(),
                remove_lrc_wd: qs('#remove-lrc').state(),
                podcast: qs('#podcast').state()
              };
  
              //  save to config.json
              pywebview.api.update_config(states);
  
              // podcasts transfer bar
              if (!states.podcast) {
                qs('sync-ui').hideBar('#podcasts-bar');
              } else {
                qs('sync-ui').showBar('#podcasts-bar');
              }
              
              //  playlist transfer bar
              if (!states.import_cues) {
                qs('sync-ui').hideBar('#playlists-bar');
              } else {
                qs('sync-ui').showBar('#playlists-bar');
              }
  
              // reset lyric files switch
              const el = qs('#remove-lrc');
              if (!states.import_lyrics) {
                await fadeOut(el);
                el.style.display = 'none';
              } else {
                el.style.removeProperty('display');
                fadeIn(el);
              }
            }
          }
  
          /**
           * set the state of the input element
           * 
           * @param {Number} newState
           */
          setState(newState) {
            this.input.checked = Boolean(newState);
            this.setAttribute('state', Number(this.input.checked));
          }
  
          /**
           * gets the state of the input element
           */
          state() {
            return Number(this.input.checked);
          }
        }
        customElements.define('audiosync-switch', AudioSyncSwitch);
  
        /**
         * progress bar
         */
        class AudioSyncProgress extends HTMLElement {
          static get observedAttributes() {
            return ["percent"];
          }
          constructor() {
            super();
            this.lastRan = 0;
            const sheet = document.createElement('style');
            sheet.textContent = `
              .label {
                display: flex;
                justify-content: space-between;
                align-items: center;
                max-width: 600px;
              }
              .wrapper {
                position: relative;
                height: 12px;
                width: 100%;
                background-color: var(--background-color);
                margin-top: 4px;
                margin-bottom: 4px;
                border: 1px solid rgb(51 51 51 / 10%);
                overflow: hidden;
                max-width: 600px;
              }
              .bar {
                position: absolute;
                top:0;
                bottom:0;
                left:0;
                right:0;
                background-color: var(--main-color);
                transform: translateX(-100%);
              }
            `;

            const label = document.createElement('div');
            label.classList.add('label');
            label.appendChild(document.createElement('slot'));

            this.bar = document.createElement('div');
            this.bar.classList.add('bar');

            const wrapper = document.createElement('div');
            wrapper.classList.add('wrapper');
            wrapper.appendChild(this.bar);

            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              label,
              wrapper
            ].forEach(el => shadow.appendChild(el));
          }
  
          connectedCallback() {
            this.setAttribute('percent', 0);
          }
  
          /**
           * percent value has changed
           * 
           * @param {String} name
           * @param {Number} oldVal
           * @param {Number} newVal
           */
          attributeChangedCallback(name, oldVal, newVal) {
            if (newVal == oldVal) return;
            const now = new Date().getTime();
            if ((now - this.lastRan) < 16) return; 
            requestAnimationFrame(_ =>{
              this.bar.style.transform = `translateX(-${100 - newVal}%)`;
            });
            this.lastRan = now;
          }
        }
        customElements.define('audiosync-progress', AudioSyncProgress);
  
        /**
         * dialog box 
         */
        class AudioSyncDialog extends HTMLElement {
          constructor() {
            super();
            const sheet = document.createElement('style');
            sheet.textContent = `
              #click-blocker {
                position: absolute;
                top:0;
                bottom:0;
                left:0;
                right:0;
                background-color: rgba(0, 0, 0, 0.4);
                pointer-events: all;
                z-index:3;
              }
              .allow-clicks {
                pointer-events: none;
                display:none;
              } 
              .dialog {
                position: absolute;
                top:150px;
                bottom:150px;
                left:25px;
                right:25px;
                color: #333333;
                padding: 24px;
                background: #fff;
                border-radius: 3px;
                box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14),0 1px 5px 0 rgba(0,0,0,0.12),0 3px 1px -2px rgba(0,0,0,0.2);
                text-align: center;
                z-index: 4;
                transform: scale3d(0, 0, 0);
                max-width: 650px;
              }
            `;

            this.blocker = document.createElement('div');
            this.blocker.id = 'click-blocker';
            this.blocker.classList.add('allow-clicks');

            this.dialog = document.createElement('div');
            this.dialog.classList.add('dialog');
            this.dialog.appendChild(document.createElement('slot'));
            
            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              this.blocker,
              this.dialog
            ].forEach(el => shadow.appendChild(el));
          }
  
          /**
           * element connected to DOM
           */
          connectedCallback() {
            if (Boolean(this.getAttribute('small'))) {
              this.dialog.style.top = '300px';
              this.dialog.style.bottom = '300px';
              this.dialog.style.left = '100px';
              this.dialog.style.right = '100px';
            }
            this.setAttribute('opened', 0);
          }
  
          /**
           * open the dialog
           */
          async open() {
            fadeIn(this.blocker);
            this.blocker.classList.remove('allow-clicks');
            await animateElement(this.dialog, 'scale3d(1, 1, 1)', 250);
            this.setAttribute('opened', 1);
          }
  
          /**
           * close the dialog
           */
          async close() {
            fadeOut(this.blocker);
            await animateElement(this.dialog, 'scale3d(0, 0, 0)', 250);
            this.blocker.classList.add('allow-clicks');
            this.setAttribute('opened', 0);
          }
        }
        customElements.define('audiosync-dialog', AudioSyncDialog);
  
        /**
         * tabs
         */
        class AudioSyncTabs extends HTMLElement {
          static get observedAttributes() {
            return ["selected"];
          }
          constructor() {
            super();
            const sheet = document.createElement('style');
            sheet.textContent = `
              slot {
                display: flex;
                flex-direction: row;
                position: relative;
                background-color: var(--background-color);
              }
            `;
            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              document.createElement('slot')
            ].forEach(el => shadow.appendChild(el));
            qs('slot', this.shadowRoot).addEventListener('slotchange', this.handleSlotChange.bind(this));
          }
  
          /**
           * connected to DOM callbback
           */
          connectedCallback() {
            this.setAttribute('selected', 0);
          }
  
          /**
           * attribute has changed 
           * 
           * @param {String} name
           * @param {Number} oldVal
           * @param {Number} newVal
           */
          attributeChangedCallback(name, oldVal, newVal) {
            if (newVal == oldVal) return;
            const pages = qs('audiosync-pages');
            if (pages) pages.setAttribute('selected', newVal);
          }
  
          /**
           * things added to the slot
           * 
           * @param {Event} event
           */
          handleSlotChange(event) {
            const assignedElements = event.target.assignedElements({flatten: true}).filter(node => node.nodeType === Node.ELEMENT_NODE);
            assignedElements[Number(this.getAttribute('selected'))].classList.add('selected');
            assignedElements.forEach((el, i) => {
              el.onClick(e => {
                if (Boolean(this.getAttribute('disabled'))) return;
                createRipple(e);
                assignedElements.forEach(ele => ele.classList.remove('selected'));
                this.setAttribute('selected', i);
                el.classList.add('selected');
              });
            });
          }
        }
        customElements.define('audiosync-tabs', AudioSyncTabs);
  
        /**
         * pages
         */
        class AudioSyncPages extends HTMLElement {
          static get observedAttributes() {
            return ["selected"];
          }
          constructor() {
            super();
            this.animationTime = 200;
            const shadow = this.attachShadow({mode: "open"});
            shadow.appendChild(document.createElement('slot'));
          }
  
          /**
           * element connected to DOM
           */
          connectedCallback() {
            this.setAttribute('selected', 0);
          }
  
          /**
           * attribute has changed
           * 
           * @param {String} name
           * @param {Number} oldVal
           * @param {Number} newVal
           */
          async attributeChangedCallback(name, oldVal, newVal) {
            const sleepTime = 20;
  
            // when run without lib_data.json one of not both values will be null
            // this gives music-library proirity 
            if (oldVal === null) {
              oldVal = 1;
              newVal = 0;
              await sleep(sleepTime);
            }
            
            // elements in the customelement "slot"
            const assignedElements = qs('slot', this.shadowRoot).assignedElements({flatten: true}).filter(node => node.nodeType === Node.ELEMENT_NODE);
            if (assignedElements[newVal] && assignedElements[oldVal]) {
  
              // transition to this page
              const to = assignedElements[newVal];
  
              // tansition from this page
              const from = assignedElements[oldVal];
  
              // hide content we are animating from 
              await fadeOut(from, this.animationTime);
              await sleep(sleepTime);
  
              // enable display of content to be animated into view
              to.style.display = 'block';
  
              // capture element heights
              const fromHeight = elementHeight(from);
              const toHeight = elementHeight(to);
  
              // animate height if the content is small enough to see the bottom of the card
              if (toHeight < 700 || fromHeight < 700) {
  
                // set height of new content before hiding old content
                to.style.height = `${fromHeight}px`;
                from.style.display = 'none';
  
                // let changes "settle" before triggering animations
                await sleep(sleepTime);
  
                // animate height of the element to new height
                await animateHeight(to, `${toHeight}px`, this.animationTime);
                await sleep(sleepTime);
                to.style.removeProperty('height');
              } else {
                from.style.display = 'none';
              }
              await sleep(sleepTime);
              fadeIn(to, this.animationTime);
            } else {
              console.error(newVal, oldVal);
            }
          }
        }
        customElements.define('audiosync-pages', AudioSyncPages);
  
        /**
         * displays podcast show info
         */
        class AudioSyncPodcasts extends HTMLElement {
          constructor() {
            super();
            // refresh icon path (will be used to loading icon later)
            this.iconPath = "M480-160q-134 0-227-93t-93-227q0-134 93-227t227-93q69 0 132 28.5T720-690v-110h80v280H520v-80h168q-32-56-87.5-88T480-720q-100 0-170 70t-70 170q0 100 70 170t170 70q77 0 139-44t87-116h84q-28 106-114 173t-196 67Z";

            // bind this
            this._resetCheckMarks = this._resetCheckMarks.bind(this);

            const sheet = document.createElement('style');
            sheet.textContent = `
              @keyframes ripple-animation {
                to {
                  transform: scale(2);
                  opacity: 0;
                }
              }
              .ripple {
                position: relative;
                overflow: hidden;
                transform: translate3d(0, 0, 0);
              }
              .ripple-effect {
                position: absolute;
                border-radius: 50%;
                background: rgba(0, 0, 0, 0.4);
                animation: ripple-animation 0.7s linear;
              }
              svg {
                width:24px;
                height:24px;
                display: flex;
                pointer-events: none;
              }
              .small-button {
                padding: 8px;
                cursor: pointer;
                overflow: hidden;
                position: relative;
                border-radius: 50%;
              }
              .small-button:hover {
                transform: scale(1.1);
              }
              .small-button[disabled] {
                color:grey;
                pointer-events: none;
              }
              .small-button > * {
                pointer-events: none;
              }
              .container {
                padding: 8px;
                display: flex;
                flex-direction: column;
                jusify-content: space-between;
              }
              .wrapper {
                display: flex;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                border-top: 1px solid #3333333d;
                padding: 8px;
                font-size: 14px;
                font-weight: bold;
                min-height: 40px;
              }
              .head {
                width: 100%;
                display: flex;
                justify-content: space-between;
              }
              @keyframes spin {
                from {
                  transform: rotate(0deg)
                }
                to {
                  transform: rotate(360deg);
                }
              }
              .spinning {
                animation: spin 1.5s linear infinite;
              }
            `;
               
            // element to append podcasts to
            this.container = document.createElement('div');
            this.container.classList.add('container');
  
            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              this.container
            ].forEach(el => shadow.appendChild(el));
          }

          /**
           * generate head element with close button
           */
          _generateHead() {
            // plus sign icon
            const addIcon = svgIcon(
              "M440-440H200v-80h240v-240h80v240h240v80H520v240h-80v-240Z",
              true
            );

            // wrappper for plus icon
            const addButton = document.createElement('div');
            addButton.appendChild(addIcon);
            addButton.classList.add('small-button');
            addButton.onClick(e => {
              if (Boolean(addButton.getAttribute('disabled'))) return;
              createRipple(e);
              this._openAddPodcastDialog();
            });

            // refresh icon
            this.svg = svgIcon(
              this.iconPath,
              true
            );
            
            // refresh button
            const refresh = document.createElement('div');
            refresh.appendChild(this.svg);
            const buttons = [addButton, refresh];
            refresh.classList.add('small-button'); 
            refresh.onClick(async e => {
              if (Boolean(refresh.getAttribute('disabled'))) return;
              createRipple(e);
              buttons.forEach(el => el.setAttribute('disabled', 1));
              this.svg.classList.add('spinning');
              const t = new Timer('Podcasts Update');
              await pywebview.api.get_podcasts();
              new Toast(t.endString());
              buttons.forEach(el => el.removeAttribute('disabled'));
              await this._resetCheckMarks();
            });
  
            // podcast tab header 
            const head = document.createElement('div');
            buttons.forEach(el => head.appendChild(el));
            head.classList.add('head');
            return head;
          }

          /**
           * creates and opens the add podcast UI
           */
          async _openAddPodcastDialog() {
            const addUI = await this._addPodcastUI();
            qs('body').appendChild(addUI);
            await sleep(20);
            addUI.open();
          }

          /** 
           * creates the UI for adding podcasts to subscriptions
           */
          async _addPodcastUI() {
            //  loading animation
            const icon = svgIcon(this.iconPath, true);
            icon.style.height = '40px';
            icon.style.width = '40px';
            icon.classList.add('spinning');
            
            // container for animated loading Icon
            const loader = document.createElement('div');
            loader.classList.add('loading');
            loader.appendChild(icon);

            // text input label
            const label = document.createElement('label');
            label.classList.add('form__label');
            label.textContent = 'Podcast XML URL';
            label.setAttribute('for', 'url');
            
            // URL input
            const input = document.createElement('input');
            input.setAttribute('placeholder', 'Podcast XML URL');
            input.type = 'url';
            input.id = 'url';
            input.classList.add('form__field');

            
            // input and label wrapper
            const group = document.createElement('div');
            group.classList.add('form__group');
            [
              input,
              label
            ].forEach(el => group.appendChild(el));
            
            // submit / add button
            const button = document.createElement('audiosync-button');
            button.textContent = 'add';
            button.setAttribute('disabled', 1);
            
            // X icon
            const closeIcon = svgIcon(
              "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z",
              false,
              'red'
            );
            
            // X button
            const closeButton = document.createElement('div');
            closeButton.appendChild(closeIcon);
            closeButton.classList.add('small-button');
            
            // dialog header 
            const closeWrapper = document.createElement('div');
            closeWrapper.classList.add('close-wrapper');
            closeWrapper.appendChild(closeButton);
            
            // animated dialog card
            const dialog = document.createElement('audiosync-dialog');
            dialog.setAttribute('small', 1);
            [
              closeWrapper,
              group,
              button,
              loader
            ].forEach(el => dialog.appendChild(el));
            
            // input callback
            input.oninput = e => {
              // enable button for valid url only
              if (isValidURL(input.value)) {
                button.removeAttribute('disabled');
              } else {
                button.setAttribute('disabled', 1);
              }
            };

            // closes the dialog
            closeButton.onClick(async e => {
              createRipple(e);
              await dialog.close();
              await sleep(100);
              dialog.remove();
            });
            
            // add button clicked
            button.onClick(async e => {
              if (Boolean(button.getAttribute('disabled'))) return;
              const loading = qs('.loading');
              loading.style.display = 'flex';
              pywebview.api.subscribe(input.value);
              await fadeIn(loading);
            });
            
            // if clipboard data is a url fill in the input element
            const pasteData = await pywebview.api.get_clipboard();
            if (isValidURL(pasteData)) {
              input.value = pasteData;
              button.removeAttribute('disabled');
            }

            return dialog;
          }

          /**
           * responds to subscription input
           * 
           * @param {String} message
           */
          async subResponse(message) {
            new Toast(message);
            await sleep(3000);

            if (message === "Subscribed!") {
              await this.listPodcasts();
            }

            const dialog = qs('audiosync-dialog');
            if (!dialog) return;
            dialog.close();
            await sleep(100);
            dialog.remove();
          }
  
          /**
           * list podcasts
           */
          async listPodcasts() {
            const podcasts = await pywebview.api.list_subscriptions();
            this.container.innerHTML = '';
            this.container.appendChild(this._generateHead());
            await podcasts.forEach(url => this._fetchAndParseXML(url));
          }
  
          /**
           * resets all checkmarks 
           */
          _resetCheckMarks() {
            qsa('.wrapper', this.shadowRoot).forEach(async el => {
              await sleep(5000);
              await fadeOut(qs('svg', el));
              this.svg.classList.remove('spinning');
            });
          }
  
          /**
           * Convert bytes per second (bps) to a human-readable format
           * 
           * @param {Number} bps - Download speed in bytes per second
           * 
           * @returns {String} - Download speed in a human-readable format
           */
          _formatDownloadSpeed(bps) {
            if (bps < 1000) {
              return bps.toFixed(2) + ' bps';
            } else if (bps < 1000000) {
              return (bps / 1000).toFixed(2) + ' kbps';
            } else {
              return (bps / 1000000).toFixed(2) + ' Mbps';
            }
          }
  
          /**
           * update bar wirh podcast download progress
           * 
           * @param {String} name
           * @param {Number} bytes
           * @param {Number} total_bytes
           * @param {Number} start_time
           * @param {String} filname
           */
          async update(name, bytes, total_bytes, start_time, filename) {
            if (filename) {
              const timepast = (new Date().getTime() - start_time) / 1000;
              const speed = this._formatDownloadSpeed(bytes / timepast);
              const bar = this.shadowRoot.getElementById(`${name}-bar`);
              const downloaded = ((bytes / total_bytes) * 100);
              
              bar.style.removeProperty('display');
              fadeIn(bar);
              qs('#title', bar).textContent = filename;
              qs('#percent', bar).textContent = `${downloaded.toFixed(1)}% @ ${speed}`;
              bar.setAttribute('percent', downloaded);
              
              if (downloaded == 100) {
                await fadeOut(bar);
                bar.style.display = 'none';
                new Toast(`${filename} downloaded`);
                qs('#title', bar).textContent = '';
                qs('#percent', bar).textContent = '';
              }
            } else {
              const svg = qs('svg', this.shadowRoot.getElementById(name));
              fadeIn(svg);
            }
          }

          /**
           * alot of code just to get the name of a podcast and put it in a html element
           * 
           * @param {String} url podcast url
           */
          _fetchAndParseXML(url) {
            fetch(url).then(response => response.text()).then(xmlString => {
              const parser = new DOMParser();
              const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
  
              // title of the podcast
              const podcastTitle = document.createElement('div');
              podcastTitle.textContent = xmlDoc.querySelector('channel').querySelector('title').textContent
              
              const svg = svgIcon(
                "M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z", 
                true, 
                'green'
              );
              svg.style.opacity = 0;

              const removeIcon = svgIcon(
                "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z",
                false,
                'red'
              );
              const removeButton = document.createElement('div');
              removeButton.appendChild(removeIcon);
              removeButton.classList.add('small-button');
              removeButton.style.opacity = 0;
              removeButton.onClick(async ev => {
                createRipple(ev)

                //  loading animation
                const icon = svgIcon(this.iconPath, true);
                icon.style.height = '40px';
                icon.style.width = '40px';
                icon.classList.add('spinning');
                
                // container for animated loading Icon
                const loader = document.createElement('div');
                loader.classList.add('loading');
                loader.appendChild(icon);

                const text = document.createElement('div');
                text.classList.add('delete-notification-text');
                text.textContent = `Unsubscribe from "${podcastTitle.textContent}"?`;
                
                const dialog = document.createElement('audiosync-dialog');
                dialog.setAttribute('small', 1);

                const yes = document.createElement('audiosync-button');
                const no = document.createElement('audiosync-button');
                const buttons = [yes,no];

                yes.textContent = 'yes';
                yes.setAttribute('color', 'red');
                yes.onClick(async e => {
                  if (Boolean(yes.getAttribute('disabled'))) return;
                  buttons.forEach(button => button.setAttribute('disabled', 1));
                  loader.style.display = 'flex';
                  await fadeIn(loader);
                  await pywebview.api.unsubscribe(url);
                  new Toast(`${podcastTitle.textContent} unsubscribed`);
                  await sleep(200);
                  await dialog.close();
                  this.listPodcasts();
                  dialog.remove();
                });

                no.textContent = 'no';
                no.setAttribute('color', '#ffffff');
                no.onClick(async e => {
                  if (Boolean(no.getAttribute('disabled'))) return;
                  buttons.forEach(button => button.setAttribute('disabled', 1));
                  await dialog.close();
                  dialog.remove();
                });

                [loader,text,yes,no].forEach(el => dialog.appendChild(el));
                qs('body').appendChild(dialog);
                await sleep(20);
                dialog.open();
              });
              
              // wrapper for title and checkmark
              const wrapper = document.createElement('div');
              [
                podcastTitle,
                svg
              ].forEach(el => wrapper.appendChild(el));
              wrapper.classList.add('wrapper');
              wrapper.id = url;

              // show remove button on mouse over
              wrapper.onmouseenter = _ => {
                if (this.svg.classList.contains('spinning')) return;
                wrapper.appendChild(removeButton);
                fadeIn(removeButton);
              };

              // hide remove button when mouse leaves element
              wrapper.onmouseleave = async _ => {
                await fadeOut(removeButton);
                removeButton.remove();
              };
  
              // will be filled with podcast episode filename
              const title = document.createElement('div');
              title.id = 'title';
  
              // download percentage
              const percent = document.createElement('div');
              percent.id = 'percent';
  
              // file download progress (hidden untill download begins)
              const bar = document.createElement('audiosync-progress');
              [
                title,
                percent
              ].forEach(el => bar.appendChild(el));
              bar.id = `${url}-bar`;
              bar.style.opacity = 0;
              bar.style.display = 'none';
  
              // push content to UI
              [
                wrapper,
                bar
              ].forEach(el => this.container.appendChild(el));
            }).catch(error => console.error('Error fetching XML:', error));
          }
        }
        customElements.define('audiosync-podcasts', AudioSyncPodcasts);
  
        /**
         * sync ui 
         */
        class SyncUI extends HTMLElement {
          constructor() {
            super();

            const sheet = document.createElement('style');
            sheet.textContent = `
              .console-output {
                height: 150px;
                font-size: 15px;
                display: flex;
                flex-direction: column;
                justify-content: flex-end;
                margin-top: 8px;
                margin-bottom: 8px;
              }
              .console-output div {
                margin-bottom: 4px;
              }
              .summary {
                margin-top:16px;
                margin-bottom:24px;
                height: 50px;
                font-size: 16px;
              }
            `;

            this._closeDialog = this._closeDialog.bind(this);

            const bars = [
              {id:"files", text: "Copying Files"},
              {id:"podcasts", text: "Copying Podcasts"},
              {id:"playlists", text: "Copying Playlists"}
            ]

            this.output = document.createElement('div');
            this.output.classList.add('console-output');

            this.summary = document.createElement('div');
            this.summary.classList.add('summary');
            
            this.button = document.createElement('audiosync-button');
            this.button.textContent = 'close';
            this.button.setAttribute('disabled', 1);
            this.button.onClick(e => {
              this._closeDialog(e);
            });
            
            this.dialog = document.createElement('audiosync-dialog');
            [
              this.output,
              this._progressBar(bars[0]),
              this._progressBar(bars[1]),
              this._progressBar(bars[2]),
              this.summary,
              this.button
            ].forEach(el => this.dialog.appendChild(el));

            const shadow = this.attachShadow({mode: "open"});
            [
              sheet,
              this.dialog
            ].forEach(el => shadow.appendChild(el));
          }

          /**
           * generates a progressbar and nested elements
           * 
           * @param {Object} obj id and text 
           * 
           * @returns {HTMLElement} 
           */
          _progressBar(obj) {
            const label = document.createElement('div');
            label.textContent = obj.text;

            const percent = document.createElement('div');
            percent.textContent = '0%';
            percent.id = `${obj.id}-bar-text`;

            const bar = document.createElement('audiosync-progress');
            bar.id = `${obj.id}-bar`;
            [
              label,
              percent
            ].forEach(el => bar.appendChild(el));
            return bar;
          }

          /**
           * hides a progress bar with the name provided
           * 
           * @param {String} name
           */
          hideBar(name) {
            if (!qs(name, this.shadowRoot)) return;
            qs(name, this.shadowRoot).style.display = 'none';
          }

          /**
           * displays the hidden bar
           * 
           * @param {String} name
           */
          showBar(name) {
            if (!qs(name, this.shadowRoot)) return;
            qs(name, this.shadowRoot).style.display = 'block';
          }

          /**
           * opens the sync ui dialog
           */
          open() {
            this.dialog.open();
          }
  
          /**
           * update the UI of sync dialog
           * 
           * @param {Object} obj
           */
          async syncUpdate(obj) {
            const div = document.createElement('div');
            div.style.opacity = 0;
            div.textContent = obj.text;
            if (!obj.summary) {
              this.output.appendChild(div);
            } else {
              new Toast('Sync Complete');
              this.summary.appendChild(div);
              this.button.removeAttribute('disabled');
            }
            if (obj.toast) {
              new Toast(obj.text);
            } else {
              console.log(obj.text);
            }
            await sleep(10);
            fadeIn(div, 150);
          }
  
          /**
           * update data of progress bars
           * 
           * @param {String} name
           * @param {Number} ndx
           * @param {Number} length
           */
          updateBar(name, ndx, length) {
            const percent = ((ndx + 1) / length) * 100;
            qs(name, this.shadowRoot).setAttribute('percent', percent);
            qs(`${name}-text`, this.shadowRoot).textContent = percent.toFixed(1) + '%';
          }
  
          /**
           * transfer dialog close button clicked
           * 
           * @param {Event} e
           */
          async _closeDialog(e) {
            if (Boolean(e.target.getAttribute('disabled'))) return;
            const ml = qs('music-library');
            await ml.go();
            qs('audiosync-menu').footElement(ml.libSize);
            await this.dialog.close();
            this.button.setAttribute('disabled', 1);
            [
              this.output,
              this.summary
            ].forEach(id => {
              id.innerHTML = '';
            });
            [
              '#files-bar', 
              '#podcasts-bar', 
              '#playlists-bar'
            ].forEach(id => {
              qs(id, this.shadowRoot).setAttribute('percent', 0);
              qs(`${id}-text`, this.shadowRoot).textContent = '0%';
            });
          }
        }
        customElements.define('sync-ui', SyncUI);

        /**
         * setup listeners and fetch data
         */
        async function load_app() {
  
          /**
           * checks overflow for messages and displays them after the last toast has expired
           */
          setInterval(_ => {
            if (!_toastCache.length) {
              return;
            }
            if (qs('#toast')) {
              return;
            }
            new Toast(
              _toastCache[0][0],
              _toastCache[0][1],
              _toastCache[0][2],
              _toastCache[0][3]
            );
            _toastCache.splice(0,1);
          }, 500);
  
          // header hamburger icon
          qs('#menu-button').onClick(event => {
            if (Boolean(event.target.getAttribute('disabled'))) return;
            createRipple(event);
            qs('audiosync-menu').open();
          });
  
          // header gear icon
          qs('#settings').onClick(event => {
            if (Boolean(event.target.getAttribute('disabled'))) return;
            createRipple(event);
            qs('audiosync-settings').open()
          });
  
          // menu drawer save / file icon
          qs('#save').onClick(async event => {
            createRipple(event);
            qs('audiosync-menu').close();
            const dataObj = qs('music-library').buildObject();
            if (Object.keys(dataObj).length === 0) {
              new Toast('No albums selected');
              return
            }
            pywebview.api.save(JSON.stringify(dataObj, null, 2));
            new Toast('JSON saved');
          });
  
          // menu drawer refresh / update icon
          qs('#update').onClick(async event => {
            createRipple(event);
            qs('audiosync-menu').close();
            await qs('sync-ui').open();
            await pywebview.api.run_sync();
          });
  
          // top of screen alert
          qs('#alert').onClick(async event => {
            createRipple(event);
            await sleep(200);
            await animateElement(event.target, 'translateY(-120%)', 800, 0);
          });
  
          // get settings from config.json
          conf = await pywebview.api.get_config();

          // playlist import ui
          qs('#cues').setState(conf.import_cues);
          if (!conf.import_cues) {
            qs('sync-ui').hideBar('#playlists-bar');
          }
  
          // lyrics import
          qs('#lyrics').setState(conf.import_lyrics);
          qs('#remove-lrc').setState(conf.remove_lrc_wd);
  
          // podcast import ui
          qs('#podcast').setState(conf.podcast);
          if (!conf.podcast) {
            qs('sync-ui').hideBar('#podcasts-bar');
          }
  
          // reset .lrc UI
          const rm_lrc_el = qs('#remove-lrc');
          if (!conf.import_lyrics) {
            rm_lrc_el.style.opacity = 0;
            rm_lrc_el.style.display = 'none';
          } else {
            rm_lrc_el.style.opacity = 1;
            rm_lrc_el.style.removeProperty('display');
          }
  
          // load media library
          const ml = qs('music-library');
          await ml.go();
          qs('audiosync-menu').footElement(ml.libSize);
  
          // load podcasts from config and generate UI
          await qs('audiosync-podcasts').listPodcasts();
  
          // load screen animation
          qs('audiosync-loader').reveal();
  
          // load time output
          console.log(t.endString());  
        }
  
        /**
         * application loaded begin startup
         */
        window.addEventListener('pywebviewready', load_app);
  
        window.onerror = async function(message, source, lineno, colno, error) {
          console.error('Error:', message, 'at', source, 'line:', lineno, 'column:', colno);
          alertUser(`Error: ${message} at ${source} line:${lineno} column:${colno}`);
          return true;
        };

      })()

    </script>

    <!-- place to display errors and issues -->
    <div id="alert" class="alert hidden">
      <div id="alert-text"></div>
      <div class="yellow-text">Click to dismiss</div>
    </div>

    <!-- hide the app while loading UI data -->
    <audiosync-loader>
      Loading...
    </audiosync-loader>
    
    <!-- header bar -->
    <audiosync-header>
      <div class="small-button" id="menu-button">
        <svg xmlns="http://www.w3.org/2000/svg">
          <path fill="currentColor" d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
        </svg>
      </div>
      <div class="small-button" id="settings">
        <svg xmlns="http://www.w3.org/2000/svg">
          <path fill="currentColor" d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
      </div>
    </audiosync-header>

    <!-- hamburger menu -->
    <audiosync-menu>
      <div id="save" class="menu-button">
        <svg xmlns="http://www.w3.org/2000/svg">
          <path fill="currentColor" d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/>
        </svg>
        <div>
          save json
        </div>
      </div>
      <div id='update' class="menu-button">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
          <path fill="currentColor"  d="M160-160v-80h110l-16-14q-52-46-73-105t-21-119q0-111 66.5-197.5T400-790v84q-72 26-116 88.5T240-478q0 45 17 87.5t53 78.5l10 10v-98h80v240H160Zm400-10v-84q72-26 116-88.5T720-482q0-45-17-87.5T650-648l-10-10v98h-80v-240h240v80H690l16 14q49 49 71.5 106.5T800-482q0 111-66.5 197.5T560-170Z"/>
        </svg>
        <div>
          Sync
        </div>
      </div>
    </audiosync-menu>

    <!-- app main body -->
    <scroll-element>
      <div class="card">
        <audiosync-tabs>
          <div class="tab">Music Lib</div>
          <div class="tab">Podcasts</div>
        </audiosync-tabs>
        <audiosync-pages>
          <music-library></music-library>
          <audiosync-podcasts style="opacity:0;"></audiosync-podcasts>
        </audiosync-pages>
      </div>
    </scroll-element>

    <!-- sync dialog -->
    <sync-ui></sync-ui>

    <!-- settings drawer -->
    <audiosync-settings>
      <audiosync-switch id="cues">
        Import playlists
      </audiosync-switch>
      <audiosync-switch id="lyrics">
        Import lyrics
      </audiosync-switch>
      <audiosync-switch id="remove-lrc" >
        Generate new LRC files
      </audiosync-switch>
      <audiosync-switch id="podcast">
        Import podcast
      </audiosync-switch>
    </audiosync-settings>
  </body>
</html>